<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Usage_of_the_package">
<Heading>Usage of the package</Heading>

<P/>
<Section Label="Chapter_Usage_of_the_package_Section_Introduction">
<Heading>Introduction</Heading>

<P/>
The &GAP; package <Package>BlissInterface</Package> provides a low level
interface to the software <URL Text="bliss: A Tool for Computing
Automorphism Groups and Canonical Labelings of
Graphs">http://www.tcs.hut.fi/Software/bliss/</URL>,
written by Tommi Junttila and Petteri Kaski.
<P/>
The only interest of this package is the computation of the group
of colour preserving automorphisms of coloured graphs. The graphs
can be directed or undirected, bipartite or not. Duplicate edges
between vertices are ignored but try to avoid introducing them in
the first place as they are not ignored immediately but will
consume memory and computation resources for a while.
<P/>
For more specialized algorithms and methods of the theory of graphs,
we recommend the packages <Package>Digraphs</Package> and
<Package>GRAPE</Package>.
<P/>
</Section>


<Section Label="Chapter_Usage_of_the_package_Section_Installation">
<Heading>Installation</Heading>

<P/>
<List>
<Item>
Download the package from <URL>https://github.com/nagygp/BlissInterface</URL>.
</Item>
<Item>
Unzip/untar the file, this should create a directory called <F>BlissInterface*</F>.
</Item>
<Item>
Locate the <F>pkg</F> directory of your &GAP; directory, which contains the
directories <F>lib</F>, <F>doc</F> and so on. Move the directory
<F>BlissInterface*</F> into the <F>pkg</F> directory.
</Item>
<Item>
Alternatively, you can use your <F>pkg</F> directory. Make sure it is in your
&GAP; root path.
</Item>
<Item>
It is necessary to compile the &BlissInterface; package. Inside the
<F>pkg/BlissInterface*</F> directory, type
<Listing>
<![CDATA[./configure
make]]></Listing>
</Item>
<Item>
Start &GAP; in the usual way (i.e. type <C>gap</C> at the command line).
</Item>
<Item>
Type <C>LoadPackage("blissinterface");</C>
</Item>
<Item>
For questions, remarks and issues please use the
<URL Text="issue tracker">https://github.com/nagygp/BlissInterface/issues</URL>.
</Item>
</List>
<P/>
</Section>


<Section Label="Chapter_Usage_of_the_package_Section_Functionality">
<Heading>Functionality</Heading>

<P/>
This section will describe the two functions of <Package>BlissInterface</Package>,
and their nonchecking counterparts.
<ManSection>
  <Func Arg="n, outneigh, colours, isdirected" Name="BlissGraphCanonicalLabeling" />
 <Returns>The pair <C>[gens,cl]</C> as GAP object, where <C>gens</C> is a list of generators for for the group of colour preserving automorphisms of the graph <C>G</C>, and <C>cl</C> is a canonical labeling of <C>G</C>.
</Returns>
 <Description>
The coloured graph <C>G</C> has vertices <C>[1..n]</C>.
If <A>isdirected</A> is <C>true</C> the <C>G</C> is directed.
The edges of <C>G</C> are given by <A>outneigh</A>, which is a list
<C>[N_1,...,N_n]</C>, such that <C>N_i</C> is the list of (out)neighbors
of the vertex <C>i</C>. Duplicate edges between vertices and loops are ignored.
<P />If <A>colours</A> is a list of length <C>n</C> then its elements are used to
define a vertex colouring of <C>G</C>, otherwise all vertices have colour <C>0</C>.
<P />This function has a nonchecking version <C>BLISS_GRAPH_CANONICAL_LABELING</C>
with the same parameters. Clearly, the nonchecking version is slightly faster
but it must be used with extreme care. Bad parameters may result in unpredictable
behaviour.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="n, m, outneigh, ucolours, lcolours" Name="BlissBipartiteCanonicalLabeling" />
 <Returns>The pair <C>[gens,cl]</C> as GAP object, where <C>gens</C> is a list of generators for <C>Aut(G)</C> and <C>cl</C> is a canonical labeling of <C>G</C>. The pair <C>[gens,cl]</C> as GAP object, where <C>gens</C> is a list of generators for for the group of colour preserving automorphisms of the directed bipartite graph <C>G</C>, and <C>cl</C> is a canonical labeling of <C>G</C>.
</Returns>
 <Description>
The coloured, directed, bipartite graph <C>G</C> has vertices
<C>[1..n+m]</C>. Upper vertices are <C>[1..n]</C>, lower vertices are
<C>[n+1..n+m]</C>. Edges point bottom up.
The edges of <C>G</C> are given by <A>outneigh</A>, which is a list
<C>[N_1,...,N_n]</C>, such that <C>N_i</C> is the list of outneighbors
of the lower vertex <C>n+i</C>. Duplicate edges between vertices and
loops are ignored.
<P />If <A>ucolours</A> is a list of length <C>n</C> then its elements
are used to define a colouring of the upper vertices, otherwise all
upper vertices have colour <C>0</C>. Similarly, if <A>lcolours</A>
is a list of length <C>m</C> then it defines a colouring of the lower
vertices.
<P />This function has a nonchecking version <C>BLISS_BIPARTITE_CANONICAL_LABELING</C>
with the same parameters. Clearly, the nonchecking version is slightly
faster but it must be used with extreme care. Bad parameters may result
in unpredictable behaviour.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Usage_of_the_package_Section_Examples">
<Heading>Examples</Heading>

<P/>
Using the point-line graph <Math>\Gamma</Math> of the Fano plane <Math>PG(2,2)</Math>, we can compute its
collineation group <Math>PSL(3,2)</Math>. By colouring the vertices of <Math>\Gamma</Math>, we get
stabilizers of points and/or line.
<P/>
<Example><![CDATA[
gap> LoadPackage( "BlissInterface", false );
true
gap> 
gap> fano:=Set([[1,2,4],[2,3,5],[3,4,6],[4,5,7],
>     [5,6,1],[6,7,2],[7,1,3]],Set);
[ [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 5, 6 ], [ 2, 3, 5 ], [ 2, 6, 7 ], 
  [ 3, 4, 6 ], [ 4, 5, 7 ] ]
gap> 
gap> bl1:=BlissBipartiteCanonicalLabeling(7, 7, fano, 0, 0);
[ [ (3,5)(6,7)(9,10)(13,14), (3,6)(5,7)(9,10)(11,12), 
      (2,3)(4,7)(8,9)(12,13), (1,2)(5,7)(9,11)(10,12) ], 
  (1,7,3,4,5,2,6)(8,14)(9,13)(10,12) ]
gap> g1:=Group(bl1[1]);
Group([ (3,5)(6,7)(9,10)(13,14), (3,6)(5,7)(9,10)(11,12), (2,3)(4,7)
(8,9)(12,13), (1,2)(5,7)(9,11)(10,12) ])
gap> Print(StructureDescription(g1),"\n");
PSL(3,2)
gap> OrbitLength(g1,fano,OnSetsSets);
1
gap> 
gap> bl1c:=BlissBipartiteCanonicalLabeling(7, 7, fano, 
>     [0,0,1,0,1,1,1], 0);
[ [ (3,5)(6,7)(9,10)(13,14), (3,7)(5,6)(11,12)(13,14), 
      (2,4)(5,6)(11,13)(12,14), (1,2)(5,7)(9,11)(10,12) ], 
  (1,3,14,5,12,4)(6,11,7,13)(8,10) ]
gap> g1c:=Group(bl1c[1]);
Group([ (3,5)(6,7)(9,10)(13,14), (3,7)(5,6)(11,12)(13,14), (2,4)(5,6)
(11,13)(12,14), (1,2)(5,7)(9,11)(10,12) ])
gap> Print(StructureDescription(g1c),"\n");
S4
gap> Orbits(g1c,[1..14]);
[ [ 1, 4, 2 ], [ 3, 6, 5, 7 ], [ 8 ], [ 9, 13, 10, 11, 14, 12 ] ]
gap> 
gap> bl1cc:=BlissBipartiteCanonicalLabeling(7, 7, fano, 0, 
>     [0,1,1,1,1,1,1]);
[ [ (3,5)(6,7)(9,10)(13,14), (3,7)(5,6)(11,12)(13,14), 
      (2,4)(5,6)(11,13)(12,14), (1,2)(5,7)(9,11)(10,12) ], 
  (1,7,3,4,5,2,6)(9,14)(10,13)(11,12) ]
gap> g1cc:=Group(bl1cc[1]);
Group([ (3,5)(6,7)(9,10)(13,14), (3,7)(5,6)(11,12)(13,14), (2,4)(5,6)
(11,13)(12,14), (1,2)(5,7)(9,11)(10,12) ])
gap> Print(StructureDescription(g1cc),"\n");
S4
gap> Orbits(g1cc,[1..14]);
[ [ 1, 4, 2 ], [ 3, 6, 5, 7 ], [ 8 ], [ 9, 13, 10, 11, 14, 12 ] ]
]]></Example>


<P/>
The automorphism group of the Petersen graphy is isomorphic to <Math>S_5</Math>.
The automorphisms preserving two disjoint 5-cycles form a dihedral group
of order 10.
<P/>
<Example><![CDATA[
gap> petersen:=[[2,5,6],[1,3,7],[2,4,8],[3,5,9],[1,4,10],
>     [1,8,9],[2,9,10],[3,6,10],[4,6,7],[5,7,8]];
[ [ 2, 5, 6 ], [ 1, 3, 7 ], [ 2, 4, 8 ], [ 3, 5, 9 ], [ 1, 4, 10 ], 
  [ 1, 8, 9 ], [ 2, 9, 10 ], [ 3, 6, 10 ], [ 4, 6, 7 ], [ 5, 7, 8 ] ]
gap> bl2:=BlissGraphCanonicalLabeling(10, petersen, false, false);
[ [ (4,8)(5,6)(9,10), (2,5,6)(3,4,9,7,10,8), (1,2,3,4,9,6)(5,7,8) ], 
  (1,10)(2,9)(3,6,8,4,5,7) ]
gap> g2:=Group(bl2[1]);
Group([ (4,8)(5,6)(9,10), (2,5,6)(3,4,9,7,10,8), (1,2,3,4,9,6)
(5,7,8) ])
gap> Print(StructureDescription(g2),"\n");
S5
gap> 
gap> bl2c:=BlissGraphCanonicalLabeling(10, petersen, 
>     [1,1,1,1,1,2,2,2,2,2], false);
[ [ (2,5)(3,4)(7,10)(8,9), (1,2,3,4,5)(6,7,8,9,10) ], 
  (1,5,3,2,4)(6,10,7)(8,9) ]
gap> g2c:=Group(bl2c[1]);
Group([ (2,5)(3,4)(7,10)(8,9), (1,2,3,4,5)(6,7,8,9,10) ])
gap> Print(StructureDescription(g2c),"\n");
D10
]]></Example>


<P/>
Let <Math>\Gamma</Math> be the direct product of two oriented cycles of size 3.
Then <Math>Aut(\Gamma)</Math> is isomorphic to <Math>(C_3 \times C_3).C_2</Math>.
<P/>
<Example><![CDATA[
gap> dir_edges:=[
>     [1,2],[2,3],[3,1],[4,5],[5,6],[6,4],[7,8],[8,9],[9,7],
>     [1,4],[4,7],[7,1],[2,5],[5,8],[8,2],[3,6],[6,9],[9,3]
> ];
[ [ 1, 2 ], [ 2, 3 ], [ 3, 1 ], [ 4, 5 ], [ 5, 6 ], [ 6, 4 ], 
  [ 7, 8 ], [ 8, 9 ], [ 9, 7 ], [ 1, 4 ], [ 4, 7 ], [ 7, 1 ], 
  [ 2, 5 ], [ 5, 8 ], [ 8, 2 ], [ 3, 6 ], [ 6, 9 ], [ 9, 3 ] ]
gap> dg:=List([1..9],i->Filtered([1..9],j->[i,j] in dir_edges));
[ [ 2, 4 ], [ 3, 5 ], [ 1, 6 ], [ 5, 7 ], [ 6, 8 ], [ 4, 9 ], 
  [ 1, 8 ], [ 2, 9 ], [ 3, 7 ] ]
gap> bl3:=BlissGraphCanonicalLabeling(9, dg, false, true);
[ [ (2,4)(3,7)(6,8), (1,2,3)(4,5,6)(7,8,9) ], (1,9)(2,7,5,4,8)(3,6) ]
gap> g3:=Group(bl3[1]);
Group([ (2,4)(3,7)(6,8), (1,2,3)(4,5,6)(7,8,9) ])
gap> Print(StructureDescription(g3),"\n");
C3 x S3
]]></Example>


<P/>
The last example shows that the same set of edges may define both
directed and undirected graphs.
<P/>
<Example><![CDATA[
gap> path:=[[2],[3],[]];
[ [ 2 ], [ 3 ], [  ] ]
gap> BlissGraphCanonicalLabeling(3, path, false, true);
[ [  ], (1,2,3) ]
gap> BlissGraphCanonicalLabeling(3, path, false, false);
[ [ (1,3) ], (1,2,3) ]
]]></Example>


</Section>


</Chapter>

